#ifndef GEOMETRY_INCLUDED
#define GEOMETRY_INCLUDED

#include "../vulkan/vk.glslh"

struct ray_t
{
    vec3 origin;
    vec3 direction;
};

struct intersection_t
{
    vec3 normal;
    float t;
    uint material_id;
};

struct attribute_index_t
{
    uint vertex_index;
    uint normal_index;
    uint texcoord_index;
};

struct triangle_idx_t
{
    attribute_index_t vertices[3];
    uint material_id;
};


struct material_t
{
    vec3 base_color;
    float roughness;
    float metallic;
};


struct light_t
{
    vec3 point;
    // It would've been automatically done by the compiler.
    float pad1;

    vec3 normal;
    float pad2;

    vec3 basis_vec0;
    float param0_max;

    vec3 basis_vec1;
    float param1_max;

    vec3 color;
    float power;
};


struct camera_t
{
    vec3 up;
    float fov;
    vec3 left;
    float aspect_ratio;
    vec3 front;
    float near;
    vec3 origin;
    float far;
};


struct scene_settings_t
{
    camera_t camera;
    uint samples_per_pixel;
    uint light_samples;
    uint max_reflection_bounces;
};


VK_DEFINE_BUFFER_TYPE(vec3)
VK_DEFINE_BUFFER_TYPE(vec2)
VK_DEFINE_BUFFER_TYPE(material_t)
VK_DEFINE_BUFFER_TYPE(light_t)
VK_DEFINE_BUFFER_TYPE(triangle_idx_t)
VK_DEFINE_BUFFER_TYPE(scene_settings_t)

layout(push_constant) uniform push_range
{
    uint vertices_id;
    uint normals_id;
    uint texcoords_id;
    uint materials_id;
    uint triangles_id;
    uint lights_id;
    uint scene_settings_id;
    uint render_output_id;
};


bool intersect_triangle(ray_t ray, triangle_idx_t triangle, inout intersection_t intersection)
{
    vec3 v0 = VK_BUFFER(vec3, vertices_id)[triangle.vertices[0].vertex_index];
    vec3 v1 = VK_BUFFER(vec3, vertices_id)[triangle.vertices[1].vertex_index];
    vec3 v2 = VK_BUFFER(vec3, vertices_id)[triangle.vertices[2].vertex_index];
    vec3 n0 = VK_BUFFER(vec3, normals_id)[triangle.vertices[0].normal_index];
    vec3 n1 = VK_BUFFER(vec3, normals_id)[triangle.vertices[1].normal_index];
    vec3 n2 = VK_BUFFER(vec3, normals_id)[triangle.vertices[2].normal_index];

    float alpha;
    float beta;
    float gamma;

    vec3 v0v2 = v2 - v0;
    vec3 v1v2 = v2 - v1;
    vec3 p = cross(v1v2, ray.direction);
    float det = dot(v0v2, p);


    if (abs(det) < EPSILON)
    {
        return false;
    }

    float inv_det = 1.0 / det;

    vec3 r = v2 - ray.origin;

    alpha = dot(r, p) * inv_det;

    if (alpha < 0 || alpha > 1)
    {
        return false;
    }

    beta = dot(cross(ray.direction, v0v2), r) * inv_det;

    if (beta < 0 || alpha + beta > 1)
    {
        return false;
    }

    gamma = 1 - beta - alpha;

    intersection.t = dot(cross(v0v2, v1v2), r) * inv_det;

    // Fill intersection info
    intersection.normal = normalize(alpha * n0 + beta * n1 + gamma * n2);
    intersection.material_id = triangle.material_id;

    return true;
}

#endif
