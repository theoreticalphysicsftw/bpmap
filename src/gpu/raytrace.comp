// Copyright 2018 Mihail Mladenov
//
// This file is part of bpmap.
//
// bpmap is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// bpmap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with bpmap.  If not, see <http://www.gnu.org/licenses/>.


#version 450
#extension GL_ARB_separate_shader_objects : enable

#define RECURSION_LIMIT 16
#define EPSILON 0.0001
#define BIAS (EPSILON * 2)
#define INFINITY 1.0 / 0.0
#define PI 3.1415927410125732421875
#define SQRT_TWO_OVER_PI 0.4501581455517614

struct camera_t
{
    vec3 up;
    float fov;
    vec3 left;
    float aspect_ratio;
    vec3 front;
    float near;
    vec3 origin;
    float far;
};


layout (std140, binding = 0) uniform scene_settings_t
{
    camera_t camera;
    uint samples_per_pixel;
    uint light_samples;
    uint max_reflection_bounces;
} scene_settings;


layout (set = 0, binding = 1, rgba32f) uniform writeonly image2D render_output;
layout (local_size_x = 8, local_size_y = 8) in;


struct attribute_index_t
{
    uint vertex_index;
    uint normal_index;
    uint texcoord_index;
};

struct triangle_t
{
    attribute_index_t vertices[3];
    uint material_id;
};


layout(set = 0, binding = 2, std430) buffer triangles_t
{
    triangle_t triangles[];
};


layout(set = 0, binding = 3, std430) buffer vertices_t
{
    vec3 vertices[];
};


layout(set = 0, binding = 4, std430) buffer normals_t
{
    vec3 normals[];
};


layout(set = 0, binding = 5, std430) buffer texcoords_t
{
    vec2 texcoords[];
};


struct material_t
{
    vec3 base_color;
    float roughness;
    float metallic;
};


layout(set = 0, binding = 6, std430) buffer materials_t
{
    material_t materials[];
};


struct light_t
{
    vec3 point;
    vec3 normal;
    vec3 basis_vec0;
    vec3 basis_vec1;
    vec3 color;
    float param0_max;
    float param1_max;


    float power;
};


layout(set = 0, binding = 7, std430) buffer lights_t
{
    light_t lights[];
};


uint reverse_bits(uint x)
{
    x = ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1);
    x = ((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2);
    x = ((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4);
    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);

    return(x >> 16) | (x << 16);
}

float van_der_corput(uint x)
{
    return reverse_bits(x) * 1e-32;
}


struct ray_t
{
    vec3 origin;
    vec3 direction;
};

struct intersection_t
{
    vec3 normal;
    float t;
    uint material_id;
};


bool intersect_triangle(ray_t ray, triangle_t triangle, inout intersection_t intersection)
{
    vec3 v0 = vertices[triangle.vertices[0].vertex_index];
    vec3 v1 = vertices[triangle.vertices[1].vertex_index];
    vec3 v2 = vertices[triangle.vertices[2].vertex_index];
    vec3 n0 = normals[triangle.vertices[0].normal_index];
    vec3 n1 = normals[triangle.vertices[1].normal_index];
    vec3 n2 = normals[triangle.vertices[2].normal_index];

    // Barycentric coordinates
    float alpha;
    float beta;
    float gamma;

    vec3 v0v1 = v1 - v0;
    vec3 v0v2 = v2 - v0;
    vec3 p = cross(ray.direction, v0v2);
    float det = dot(v0v1, p);

    // backface culling
    if (det < EPSILON)
    {
        return false;
    }

    float inv_det = 1.0 / det;

    vec3 r = ray.direction - v0;
    alpha = dot(r, p) * inv_det;

    if (alpha < 0 || alpha > 1)
    {
        return false;
    }

    vec3 q = cross(r, v0v1);
    beta = dot(ray.direction, q) * inv_det;

    if (beta < 0 || alpha + beta > 1)
    {
        return false;
    }

    gamma = 1 - alpha - beta;

    intersection.t = dot(v0v2, q) * inv_det;

    // Fill intersection info
    intersection.normal = alpha * n0 + beta * n1 + gamma * n2;
    intersection.material_id = triangle.material_id;

    return true;
}

vec3 sample_light(light_t light, uint i)
{
    float seqn = van_der_corput(i);

    return light.point +
            (light.param0_max * light.basis_vec0 +
             light.param1_max * light.basis_vec1) * seqn;
}

void reflect_ray(inout ray_t ray, vec3 normal)
{
        ray.direction = ray.direction - 2.0 * dot(normal, ray.direction) * normal;
}

vec3 diffuse_lambert(vec3 base_color)
{
        return base_color * (1 / PI);
}

float d_beckmann(float roughness, float dot_n_h)
{
        float a = roughness * roughness;
        float a_sq = a * a;
        float dot_n_h_sq = dot_n_h  * dot_n_h ;

        return exp((dot_n_h_sq - 1) / (a_sq * dot_n_h_sq)) / (PI * a_sq * dot_n_h_sq * dot_n_h_sq);
}

// This is G over dot_n_in * dot_n_out.
float g_reduced_shlick(float roughness, float dot_n_in, float dot_n_out)
{
    float k = roughness * SQRT_TWO_OVER_PI;
    float one_minus_k = 1 - k;

    float denom_in = dot_n_in * one_minus_k + k;
    float denom_out = dot_n_out * one_minus_k + k;

    return 1.0 / (denom_in * denom_out);
}

vec3 f_schlick(vec3 specular_color, float dot_h_in)
{
    float f_lambda = pow(1 - dot_h_in, 5);

    return specular_color + (1.0 - specular_color) * f_lambda;
}

vec3 brdf(vec3 out_dir, vec3 in_dir, intersection_t intersection)
{
    vec3 base_color = materials[intersection.material_id].base_color;
    float roughness = materials[intersection.material_id].roughness;
    float metallic = materials[intersection.material_id].metallic;

    vec3 half_vec = normalize(out_dir + in_dir);

    float dot_n_in = dot(intersection.normal, in_dir);
    float dot_n_out = dot(intersection.normal, out_dir);
    float dot_n_h = dot(intersection.normal, half_vec);
    float dot_h_in = dot(intersection.normal, half_vec);

    vec3 diffuse_color = base_color - base_color * metallic;
    vec3 specular_color = mix(vec3(0.025, 0.025, 0.025), diffuse_color, metallic);

    vec3 diffuse = diffuse_lambert(diffuse_color);
    vec3 f = f_schlick(specular_color, dot_h_in);
    float g_reduced = g_reduced_shlick(roughness, dot_n_in, dot_n_out);
    float d = d_beckmann(roughness, dot_n_h);

    return diffuse + (f * g_reduced * d) / 4.0;
}

vec3 shade(vec3 out_dir, vec3 in_dir, intersection_t intersection, vec3 light_color, float light_power)
{
    return light_color * light_power * brdf(out_dir, in_dir, intersection);
}


intersection_t intersect_geometry(ray_t ray)
{
    intersection_t intersection;
    intersection.t = INFINITY;

    for(uint i = 0; i < triangles.length(); ++i)
    {
        intersection_t current_intersection;

        if(intersect_triangle(ray, triangles[i], intersection))
        {
            if(current_intersection.t < intersection.t)
            {
                intersection = current_intersection;
            }
        }
    }

    return intersection;
}

vec3 direct_lighting(ray_t ray)
{
    vec3 output_color = vec3(0.0, 0.0, 0.0);

    uint light_samples = scene_settings.light_samples;

    intersection_t intersection = intersect_geometry(ray);

    if(intersection.t < INFINITY)
    {
        for(uint i = 0; i < lights.length(); ++i)
        {
            vec3 intersection_point = ray.origin + intersection.t * ray.direction;

            if(dot(lights[i].point - intersection_point, lights[i].normal) > 0)
            {
                float sample_power = lights[i].power / light_samples;

                for(uint j = 0; j < light_samples; ++j)
                {
                    vec3 light_sample = sample_light(lights[i], j);


                    ray_t shadow_ray;
                    shadow_ray.origin = intersection_point + intersection.normal * BIAS;
                    vec3 shadow_ray_vector = light_sample - intersection_point;
                    shadow_ray.direction = normalize(shadow_ray_vector);

                    intersection_t shadow = intersect_geometry(shadow_ray);

                    float light_distance = length(shadow_ray_vector);

                    if(shadow.t > light_distance)
                    {
                        output_color += shade(
                                                -ray.direction,
                                                shadow_ray.direction,
                                                intersection,
                                                lights[i].color,
                                                sample_power / (light_distance * light_distance)
                                              );
                    }
                }
            }
        }
    }

    return output_color;
}

vec3 raytrace(ray_t ray)
{
    vec3 output_color = direct_lighting(ray);

    // Add reflections here.

    return output_color;
}


void main()
{
    vec3 output_color = vec3(0.0, 0.0, 0.0);

    camera_t camera = scene_settings.camera;

    uint samples_per_pixel = scene_settings.samples_per_pixel;
    uint light_samples = scene_settings.light_samples;



    float fov_scale = 1.0 / tan(radians(camera.fov));

    vec2 image_scale = 1.0 / imageSize(render_output);
    vec2 camera_scale = fov_scale * vec2(camera.aspect_ratio, 1.0);

    vec2 raster_coords = gl_GlobalInvocationID.xy * image_scale ;



    for(uint pixel_sample = 0; pixel_sample < samples_per_pixel; ++pixel_sample)
    {
        float seqn = van_der_corput(pixel_sample);
        vec2 screen_coords = (2.0 * raster_coords + seqn * image_scale - 1.0) * camera_scale;

        ray_t ray;
        ray.origin = camera.origin;

        vec3 screen_point = ray.origin +
                            camera.front +
                            camera.left * screen_coords.x +
                            camera.up * screen_coords.y;

        ray.direction = normalize(screen_point - ray.origin);

        output_color += raytrace(ray);
    }

    output_color /= samples_per_pixel;

    imageStore(render_output, ivec2(gl_GlobalInvocationID.xy), vec4(output_color, 1.0));
}
