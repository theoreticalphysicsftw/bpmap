// Copyright 2018 Mihail Mladenov
//
// This file is part of bpmap.
//
// bpmap is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// bpmap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with bpmap.  If not, see <http://www.gnu.org/licenses/>.


#version 450
#extension GL_ARB_separate_shader_objects : enable

struct camera_t
{
    vec3 up;
    vec3 left;
    vec3 front;
    vec3 origin;

    float fov;
    float aspect_ratio;
    float near;
    float far;
};

layout (set = 0, binding = 0, std140) uniform scene_settings_t
{
    camera_t camera;
    float resolution_x;
    float resolution_y;

    uint samples_per_pixel;
    uint light_samples;
    uint max_reflection_bounces;
} scene_settings;

layout (set = 0, binding = 1, rgba32f) uniform writeonly image2D render_output;
layout (local_size_x = 8, local_size_y = 8) in;


struct attribute_index_t
{
    uint vertex_index;
    uint normal_index;
    uint texcoord_index;
};

struct triangle_t
{
    attribute_index_t vertices[3];
    uint material_id;
};


layout(set = 0, binding = 2, std430) buffer triangles_t
{
    triangle_t triangles[];
};

layout(set = 0, binding = 3, std430) buffer vertices_t
{
    vec3 vertices[];
};

layout(set = 0, binding = 4, std430) buffer normals_t
{
    vec3 normals[];
};

layout(set = 0, binding = 5, std430) buffer texcoords_t
{
    vec3 texcoords[];
};

struct material_t
{
    vec4 base_color;
    float roughness;
    float metallic;
};

layout(set = 0, binding = 6, std430) buffer materials_t
{
    material_t materials[];
};

struct light_t
{
    vec3 point;
    vec3 normal;
    vec3 basis_vec0;
    vec3 basis_vec1;
    float param0_max;
    float param1_max;


    float power;
};

layout(set = 0, binding = 7, std430) buffer lights_t
{
    light_t lights[];
};


uint reverse_bits(uint x)
{
    x = ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1);
    x = ((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2);
    x = ((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4);
    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);

    return(x >> 16) | (x << 16);
}

float van_der_corput(uint x)
{
    return reverse_bits(x) * 1e-32;
}

struct ray_t
{
    vec3 origin;
    vec3 direction;
};


vec3 raytrace(ray_t ray)
{
    // Have to do it tommorow after the exam because I'm half asleep right now.
    return vec3(1.0, 1.0, 1.0);
}

void main()
{
    vec3 output_color = vec3(0.0, 0.0, 0.0);

    camera_t camera = scene_settings.camera;

    uint samples_per_pixel = scene_settings.samples_per_pixel;
    uint light_samples = scene_settings.light_samples;

    float fov_scale = 1.0 / tan(radians(camera.fov));

    vec2 image_scale = 1.0 / imageSize(render_output);
    vec2 camera_scale = fov_scale * vec2(camera.aspect_ratio, 1.0);

    vec2 raster_coords = gl_GlobalInvocationID.xy * image_scale ;



    for(uint pixel_sample = 0; pixel_sample < samples_per_pixel; ++pixel_sample)
    {
        float seqn = van_der_corput(pixel_sample);
        vec2 screen_coords = (2.0 * raster_coords + seqn * image_scale - 1.0) * camera_scale;

        ray_t ray;
        ray.origin = camera.origin;

        vec3 screen_point = ray.origin +
                            camera.front +
                            camera.left * screen_coords.x +
                            camera.up * screen_coords.y;

        ray.direction = normalize(screen_point - ray.origin);

        output_color += raytrace(ray);
    }

    output_color /= samples_per_pixel;

    imageStore(render_output, ivec2(gl_GlobalInvocationID.xy), vec4(output_color, 1.0));
}
